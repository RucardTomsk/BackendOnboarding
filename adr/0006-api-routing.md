---
status: accepted
date: 2023-02-17
author: i.v.freydin
---
# Организация роутинга API

## Контекст и проблематика

Проблема заключается в том, чтобы аккуратно обустроить роутинг для клиентских запросов:
1. Запросы должны попадать на нужный микросервис
2. Клиенту желательно ничего не знать о тонкостях роутинга
3. Эндпоинты должны быть хорошо задокументированы

## Решающие факторы

* Возможность использования в SPA
* Клиент не должен ничего знать о серверной внутрянке

## Предлагаемое решение

Предлагается следующий **вариант устройства API**:
* Одно действие = один эндпоинт на API
* Эндпоинты версионируются
* Один запрос = одна операция (вытекает из вариантов использования)
* На каждый запрос проставляется trackingId
* Для запросов в рамках одной пользовательской сессии проставляется sessionId
* У успешных ответов и у ошибок есть базовые поля: status, trackingId, blame system (на ошибке)
* Операции по созданию сущностей возвращают фронтенду ID созданной сущности
* Название эндпоинта включает в себя префикс главной сущности, её ID (опционально) и название операции
* Эндпоинты пишем в camelCase + они могут включать несколько вложенных сущностей
* Например, `POST /api/v1/user/create` или `POST /api/v1/user/<uuid>/addEmail`
* Операции не всегда заканчиваются HTTP-ответом (они могут быть продолжены в фоне)

Каждый сервис предоставляет **свой собственный API**. Перед сервисами стоит условный балансировщик нагрузки
(например, Istio), который роутит все запросы **исходя из префиксов** сущностей. Это позволяет оформить 
**единую точку доступа** для всех клиентов, которая будет к тому же довольно тонкой и простой в масштабировании.

Для каждого сервиса выставляется **спецификация контрактов в формате Swagger**.

## Принятое решение

Принятое решение равно предлагаемому решению.
